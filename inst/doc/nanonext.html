<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.9">
<title>nanonext - Quick Reference</title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.13.61/css/prism-xcode.min.css">
</head>
<body>
<div class="frontmatter">
<div class="title"><h1>nanonext - Quick Reference</h1></div>
</div>
<div class="body">
<h2 id="sec:core-concepts">Core Concepts</h2>
<p><strong>nanonext</strong> provides bindings to NNG (Nanomsg Next Gen), a high-performance messaging library for building distributed systems.</p>
<p>This is a cheatsheet. Refer to the other vignettes for detailed introductions:</p>
<ul>
<li><a href="v01-messaging.html">Messaging and Async I/O</a> - cross-language exchange, async operations, synchronisation</li>
<li><a href="v02-protocols.html">Scalability Protocols</a> - req/rep, pub/sub, surveyor/respondent</li>
<li><a href="v03-configuration.html">Configuration and Security</a> - TLS, options, serialization, statistics</li>
<li><a href="v04-web.html">Web Toolkit</a> - HTTP client/server, WebSocket, streaming</li>
</ul>
<h2 id="sec:key-takeaways">Key Takeaways</h2>
<ul>
<li><strong>Sockets</strong> connect via URLs using scalability protocols (req/rep, pub/sub, etc.)</li>
<li><strong>Transports</strong>: <code>inproc://</code> (in-process), <code>ipc://</code> (inter-process), <code>tcp://</code>, <code>ws://</code>, <code>wss://</code>, <code>tls+tcp://</code></li>
<li><strong>Async I/O</strong>: <code>send_aio()</code> / <code>recv_aio()</code> return immediately; access results via <code>$data</code> or <code>$result</code></li>
<li><strong>Modes</strong>: <code>&quot;serial&quot;</code> (R objects), <code>&quot;raw&quot;</code> (bytes), <code>&quot;double&quot;</code>, <code>&quot;integer&quot;</code>, <code>&quot;character&quot;</code>, etc.</li>
<li><strong>Condition variables</strong>: <code>cv()</code> for zero-latency event synchronisation</li>
</ul>
<h2 id="sec:1-sockets-and-connections">1. Sockets and Connections</h2>
<h3 id="sec:create-sockets">Create Sockets</h3>
<pre><code class="language-r">library(nanonext)

# Functional interface
s &lt;- socket(&quot;pair&quot;)
listen(s, &quot;tcp://127.0.0.1:5555&quot;)
dial(s, &quot;tcp://127.0.0.1:5555&quot;)

# Object-oriented interface
n &lt;- nano(&quot;pair&quot;, listen = &quot;tcp://127.0.0.1:5555&quot;)
n$dial(&quot;tcp://127.0.0.1:5556&quot;)

# Close when done
close(s)
n$close()
</code></pre>
<h3 id="sec:protocols">Protocols</h3>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Description</th>
<th>Socket Types</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Pair</strong></td>
<td>1-to-1 bidirectional</td>
<td><code>&quot;pair&quot;</code></td>
</tr>
<tr>
<td><strong>Poly</strong></td>
<td>Polyamorous pair</td>
<td><code>&quot;poly&quot;</code></td>
</tr>
<tr>
<td><strong>Pipeline</strong></td>
<td>One-way data flow</td>
<td><code>&quot;push&quot;</code>, <code>&quot;pull&quot;</code></td>
</tr>
<tr>
<td><strong>Req/Rep</strong></td>
<td>RPC pattern</td>
<td><code>&quot;req&quot;</code>, <code>&quot;rep&quot;</code></td>
</tr>
<tr>
<td><strong>Pub/Sub</strong></td>
<td>Broadcast/subscribe</td>
<td><code>&quot;pub&quot;</code>, <code>&quot;sub&quot;</code></td>
</tr>
<tr>
<td><strong>Survey</strong></td>
<td>Query all peers</td>
<td><code>&quot;surveyor&quot;</code>, <code>&quot;respondent&quot;</code></td>
</tr>
<tr>
<td><strong>Bus</strong></td>
<td>Many-to-many mesh</td>
<td><code>&quot;bus&quot;</code></td>
</tr>
</tbody>
</table>
<h3 id="sec:transports">Transports</h3>
<table>
<thead>
<tr>
<th>URL Scheme</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>inproc://name</code></td>
<td>In-process (fastest, same process)</td>
</tr>
<tr>
<td><code>ipc:///path</code></td>
<td>Inter-process (Unix socket / named pipe)</td>
</tr>
<tr>
<td><code>tcp://host:port</code></td>
<td>TCP/IP network</td>
</tr>
<tr>
<td><code>ws://host:port/path</code></td>
<td>WebSocket</td>
</tr>
<tr>
<td><code>wss://host:port/path</code></td>
<td>WebSocket over TLS</td>
</tr>
<tr>
<td><code>tls+tcp://host:port</code></td>
<td>TLS encrypted TCP</td>
</tr>
</tbody>
</table>
<h2 id="sec:2-send-and-receive">2. Send and Receive</h2>
<h3 id="sec:synchronous">Synchronous</h3>
<pre><code class="language-r"># Send R object (serialized)
send(s, data.frame(a = 1, b = 2))

# Receive R object
recv(s)

# Send raw bytes (for cross-language exchange)
send(s, c(1.1, 2.2, 3.3), mode = &quot;raw&quot;)

# Receive as specific type
recv(s, mode = &quot;double&quot;)
recv(s, mode = &quot;character&quot;)
recv(s, mode = &quot;raw&quot;)
</code></pre>
<h3 id="sec:receive-modes">Receive Modes</h3>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;serial&quot;</code> / <code>1</code></td>
<td>R serialization (default)</td>
</tr>
<tr>
<td><code>&quot;character&quot;</code> / <code>2</code></td>
<td>Coerce to character</td>
</tr>
<tr>
<td><code>&quot;complex&quot;</code> / <code>3</code></td>
<td>Coerce to complex</td>
</tr>
<tr>
<td><code>&quot;double&quot;</code> / <code>4</code></td>
<td>Coerce to double</td>
</tr>
<tr>
<td><code>&quot;integer&quot;</code> / <code>5</code></td>
<td>Coerce to integer</td>
</tr>
<tr>
<td><code>&quot;logical&quot;</code> / <code>6</code></td>
<td>Coerce to logical</td>
</tr>
<tr>
<td><code>&quot;numeric&quot;</code> / <code>7</code></td>
<td>Coerce to numeric</td>
</tr>
<tr>
<td><code>&quot;raw&quot;</code> / <code>8</code></td>
<td>Raw bytes</td>
</tr>
<tr>
<td><code>&quot;string&quot;</code> / <code>9</code></td>
<td>Fast option for length-1 character</td>
</tr>
</tbody>
</table>
<h2 id="sec:3-async-i-o">3. Async I/O</h2>
<h3 id="sec:basic-async">Basic Async</h3>
<pre><code class="language-r"># Async send - returns immediately
res &lt;- send_aio(s, data)
res$result          # 0 = success, error code otherwise

# Async receive - returns immediately
msg &lt;- recv_aio(s)
msg$data            # Value when resolved, 'unresolved' NA otherwise

# Check if resolved
unresolved(msg)     # TRUE while pending

# Wait for resolution
call_aio(msg)       # Blocks, returns Aio object
collect_aio(msg)    # Blocks, returns value directly
msg[]               # Blocks (user-interruptible), returns value
</code></pre>
<h3 id="sec:non-blocking-patterns">Non-blocking Patterns</h3>
<pre><code class="language-r"># Poll while doing other work
while (unresolved(msg)) {
  # do other tasks
}
result &lt;- msg$data

# Multiple async operations
msg1 &lt;- recv_aio(s1)
msg2 &lt;- recv_aio(s2)
# Both run concurrently
</code></pre>
<h2 id="sec:4-condition-variables">4. Condition Variables</h2>
<h3 id="sec:basics">Basics</h3>
<pre><code class="language-r"># Create condition variable
cv &lt;- cv()

# Check/signal
cv_value(cv)        # Get counter value
cv_signal(cv)       # Increment counter
cv_reset(cv)        # Reset to zero

# Wait (blocks until counter &gt; 0, then decrements)
wait(cv)

# Wait with timeout (ms), returns FALSE on timeout
until(cv, 1000)
</code></pre>
<h3 id="sec:pipe-notifications">Pipe Notifications</h3>
<pre><code class="language-r"># Signal on connection/disconnection
pipe_notify(socket, cv = cv, add = TRUE, remove = TRUE)

# Distinguish message vs disconnect with flag
pipe_notify(socket, cv = cv, remove = TRUE, flag = TRUE)
r &lt;- recv_aio(socket, cv = cv)
wait(cv) || stop(&quot;disconnected&quot;)  # FALSE = pipe event
</code></pre>
<h3 id="sec:async-with-cv">Async with CV</h3>
<pre><code class="language-r">cv &lt;- cv()
msg &lt;- recv_aio(s, cv = cv)
wait(cv)            # Wake on receive completion
msg$data
</code></pre>
<h2 id="sec:5-request-reply-rpc">5. Request/Reply (RPC)</h2>
<h3 id="sec:server">Server</h3>
<pre><code class="language-r">rep &lt;- socket(&quot;rep&quot;, listen = &quot;tcp://127.0.0.1:5555&quot;)
ctx &lt;- context(rep)

# reply() blocks, waiting for request
reply(ctx, execute = my_function, send_mode = &quot;raw&quot;)

close(rep)
</code></pre>
<h3 id="sec:client">Client</h3>
<pre><code class="language-r">req &lt;- socket(&quot;req&quot;, dial = &quot;tcp://127.0.0.1:5555&quot;)
ctx &lt;- context(req)

# request() returns immediately
aio &lt;- request(ctx, data = args, recv_mode = &quot;double&quot;)

# Do other work while server processes...

# Get result when needed
result &lt;- aio[]

close(req)
</code></pre>
<h2 id="sec:6-pub-sub">6. Pub/Sub</h2>
<pre><code class="language-r">pub &lt;- socket(&quot;pub&quot;, listen = &quot;inproc://pubsub&quot;)
sub &lt;- socket(&quot;sub&quot;, dial = &quot;inproc://pubsub&quot;)

# Subscribe to topic (prefix matching)
subscribe(sub, topic = &quot;news&quot;)
subscribe(sub, topic = NULL)      # All topics

# Unsubscribe
unsubscribe(sub, topic = &quot;news&quot;)

# Publish (topic is message prefix)
send(pub, c(&quot;news&quot;, &quot;headline&quot;), mode = &quot;raw&quot;)

# Receive (includes topic)
recv(sub, mode = &quot;character&quot;)

close(pub)
close(sub)
</code></pre>
<h2 id="sec:7-surveyor-respondent">7. Surveyor/Respondent</h2>
<pre><code class="language-r">sur &lt;- socket(&quot;surveyor&quot;, listen = &quot;inproc://survey&quot;)
res1 &lt;- socket(&quot;respondent&quot;, dial = &quot;inproc://survey&quot;)
res2 &lt;- socket(&quot;respondent&quot;, dial = &quot;inproc://survey&quot;)

# Set survey timeout (ms)
survey_time(sur, 500)

# Broadcast survey
send(sur, &quot;ping&quot;)

# Collect responses (async)
aio1 &lt;- recv_aio(sur)
aio2 &lt;- recv_aio(sur)

# Respondents reply
recv(res1)
send(res1, &quot;pong1&quot;)

# Late/missing responses timeout (errorValue 5)
msleep(500)
aio2$data           # errorValue if no response

close(sur)
close(res1)
close(res2)
</code></pre>
<h2 id="sec:8-tls-secure-connections">8. TLS Secure Connections</h2>
<h3 id="sec:self-signed-certificates">Self-signed Certificates</h3>
<pre><code class="language-r"># Generate certificate (cn must match URL host exactly)
cert &lt;- write_cert(cn = &quot;127.0.0.1&quot;)

# Create TLS configs
server_tls &lt;- tls_config(server = cert$server)
client_tls &lt;- tls_config(client = cert$client)

# Use with tls+tcp:// or wss://
s1 &lt;- socket(listen = &quot;tls+tcp://127.0.0.1:5555&quot;, tls = server_tls)
s2 &lt;- socket(dial = &quot;tls+tcp://127.0.0.1:5555&quot;, tls = client_tls)
</code></pre>
<h3 id="sec:ca-certificates">CA Certificates</h3>
<pre><code class="language-r"># Client with CA cert file
client_tls &lt;- tls_config(client = &quot;/path/to/ca-cert.pem&quot;)

# Server with cert + key
server_tls &lt;- tls_config(server = c(&quot;/path/to/cert.pem&quot;, &quot;/path/to/key.pem&quot;))
</code></pre>
<h2 id="sec:9-options-and-statistics">9. Options and Statistics</h2>
<h3 id="sec:get-set-options">Get/Set Options</h3>
<pre><code class="language-r"># Delayed start for configuration
s &lt;- socket(listen = &quot;tcp://127.0.0.1:5555&quot;, autostart = FALSE)

# Get option
opt(s$listener[[1]], &quot;recv-size-max&quot;)

# Set option
opt(s$listener[[1]], &quot;recv-size-max&quot;) &lt;- 8192L

# Start after configuration
start(s$listener[[1]])
</code></pre>
<h3 id="sec:common-options">Common Options</h3>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;recv-size-max&quot;</code></td>
<td>Max message size (0 = unlimited)</td>
</tr>
<tr>
<td><code>&quot;send-timeout&quot;</code></td>
<td>Send timeout (ms)</td>
</tr>
<tr>
<td><code>&quot;recv-timeout&quot;</code></td>
<td>Receive timeout (ms)</td>
</tr>
<tr>
<td><code>&quot;reconnect-time-min&quot;</code></td>
<td>Min reconnect interval (ms)</td>
</tr>
<tr>
<td><code>&quot;reconnect-time-max&quot;</code></td>
<td>Max reconnect interval (ms)</td>
</tr>
<tr>
<td><code>&quot;req:resend-time&quot;</code></td>
<td>Request retry interval</td>
</tr>
<tr>
<td><code>&quot;sub:prefnew&quot;</code></td>
<td>Prefer newer messages</td>
</tr>
</tbody>
</table>
<h3 id="sec:custom-serialization">Custom Serialization</h3>
<pre><code class="language-r"># Register custom serializer for a class
serial &lt;- serial_config(
  &quot;class_name&quot;,
  function(x) serialize(x, NULL),  # serialize
  unserialize                      # unserialize
)
opt(socket, &quot;serial&quot;) &lt;- serial
</code></pre>
<h3 id="sec:statistics">Statistics</h3>
<pre><code class="language-r">stat(socket, &quot;pipes&quot;)      # Active connections
stat(listener, &quot;accept&quot;)   # Connection attempts
stat(dialer, &quot;reject&quot;)     # Rejected connections
</code></pre>
<h2 id="sec:10-contexts">10. Contexts</h2>
<p>Contexts enable concurrent operations on a single socket (for req/rep, surveyor/respondent).</p>
<pre><code class="language-r">s &lt;- socket(&quot;req&quot;, dial = &quot;tcp://127.0.0.1:5555&quot;)

# Create independent contexts
ctx1 &lt;- context(s)
ctx2 &lt;- context(s)

# Concurrent requests
aio1 &lt;- request(ctx1, data1)
aio2 &lt;- request(ctx2, data2)

# Close contexts (or they close with socket)
close(ctx1)
close(ctx2)
close(s)
</code></pre>
<h2 id="sec:11-cross-language-exchange">11. Cross-language Exchange</h2>
<h3 id="sec:r-to-python-numpy">R to Python (NumPy)</h3>
<pre><code class="language-r"># R: send raw doubles
n &lt;- nano(&quot;pair&quot;, dial = &quot;ipc:///tmp/nanonext&quot;)
n$send(c(1.1, 2.2, 3.3), mode = &quot;raw&quot;)
result &lt;- n$recv(mode = &quot;double&quot;)
</code></pre>
<pre><code class="language-python"># Python: receive as NumPy array
import numpy as np
import pynng
socket = pynng.Pair0(listen=&quot;ipc:///tmp/nanonext&quot;)
array = np.frombuffer(socket.recv())
socket.send(array.tobytes())
</code></pre>
<h2 id="sec:12-error-handling">12. Error Handling</h2>
<pre><code class="language-r"># Errors return as 'errorValue' class
result &lt;- recv(s, block = FALSE)

# Check for errors
is_error_value(result)

# Error codes
# 5  = Timed out
# 6  = Connection refused
# 8  = Try again (non-blocking, no message)

# Get error message
nng_error(5)        # &quot;Timed out&quot;
</code></pre>
<h2 id="sec:13-utilities">13. Utilities</h2>
<pre><code class="language-r"># Sleep (uninterruptible, ms)
msleep(100)

# Random bytes
random(8)                          # 8 random bytes as hex string
random(8, convert = FALSE)         # As raw vector

# Parse URL
parse_url(&quot;tcp://127.0.0.1:5555&quot;)
</code></pre>
</div>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</body>
</html>
