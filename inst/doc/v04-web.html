<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.9">
<title>nanonext - Web Toolkit</title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.13.61/css/prism-xcode.min.css">
</head>
<body>
<div class="frontmatter">
<div class="title"><h1>nanonext - Web Toolkit</h1></div>
</div>
<div class="body">
<pre><code class="language-r">library(nanonext)
</code></pre>
<p>nanonext provides high-performance HTTP/WebSocket client and server capabilities built on NNG’s networking stack with Mbed TLS for secure connections.</p>
<h3 id="sec:1-http-client">1. HTTP Client</h3>
<h4 id="sec:ncurl-basic-requests">ncurl: Basic Requests</h4>
<p><code>ncurl()</code> is a minimalist HTTP(S) client. Basic usage requires only a URL.</p>
<pre><code class="language-r">ncurl(&quot;https://postman-echo.com/get&quot;)
#&gt; $status
#&gt; [1] 200
#&gt; 
#&gt; $headers
#&gt; NULL
#&gt; 
#&gt; $data
#&gt; [1] &quot;{\&quot;args\&quot;:{},\&quot;headers\&quot;:{\&quot;host\&quot;:\&quot;postman-echo.com\&quot;,\&quot;accept-encoding\&quot;:\&quot;gzip, br\&quot;,\&quot;x-forwarded-proto\&quot;:\&quot;https\&quot;},\&quot;url\&quot;:\&quot;https://postman-echo.com/get\&quot;}&quot;
</code></pre>
<p>Advanced usage supports all HTTP methods (POST, PUT, DELETE, etc.), custom headers, and request bodies.</p>
<pre><code class="language-r">ncurl(&quot;https://postman-echo.com/post&quot;,
      method = &quot;POST&quot;,
      headers = c(`Content-Type` = &quot;application/json&quot;, Authorization = &quot;Bearer APIKEY&quot;),
      data = '{&quot;key&quot;: &quot;value&quot;}',
      response = &quot;date&quot;)
#&gt; $status
#&gt; [1] 200
#&gt; 
#&gt; $headers
#&gt; $headers$date
#&gt; [1] &quot;Sun, 08 Feb 2026 11:22:45 GMT&quot;
#&gt; 
#&gt; 
#&gt; $data
#&gt; [1] &quot;{\&quot;args\&quot;:{},\&quot;data\&quot;:{\&quot;key\&quot;:\&quot;value\&quot;},\&quot;files\&quot;:{},\&quot;form\&quot;:{},\&quot;headers\&quot;:{\&quot;host\&quot;:\&quot;postman-echo.com\&quot;,\&quot;accept-encoding\&quot;:\&quot;gzip, br\&quot;,\&quot;x-forwarded-proto\&quot;:\&quot;https\&quot;,\&quot;content-type\&quot;:\&quot;application/json\&quot;,\&quot;authorization\&quot;:\&quot;Bearer APIKEY\&quot;,\&quot;content-length\&quot;:\&quot;16\&quot;},\&quot;json\&quot;:{\&quot;key\&quot;:\&quot;value\&quot;},\&quot;url\&quot;:\&quot;https://postman-echo.com/post\&quot;}&quot;
</code></pre>
<p>Specify <code>response = TRUE</code> to return all response headers.</p>
<pre><code class="language-r">ncurl(&quot;https://postman-echo.com/get&quot;,
      response = TRUE)
#&gt; $status
#&gt; [1] 200
#&gt; 
#&gt; $headers
#&gt; $headers$Date
#&gt; [1] &quot;Sun, 08 Feb 2026 11:22:45 GMT&quot;
#&gt; 
#&gt; $headers$`Content-Type`
#&gt; [1] &quot;application/json; charset=utf-8&quot;
#&gt; 
#&gt; $headers$`Content-Length`
#&gt; [1] &quot;143&quot;
#&gt; 
#&gt; $headers$Connection
#&gt; [1] &quot;close&quot;
#&gt; 
#&gt; $headers$`CF-RAY`
#&gt; [1] &quot;9caac0420a1dc16b-LHR&quot;
#&gt; 
#&gt; $headers$etag
#&gt; [1] &quot;W/\&quot;8f-7zN8nSad8A9WlFJjKQZB04z5nHE\&quot;&quot;
#&gt; 
#&gt; $headers$vary
#&gt; [1] &quot;Accept-Encoding&quot;
#&gt; 
#&gt; $headers$`Set-Cookie`
#&gt; [1] &quot;sails.sid=s%3A3tYl-iuzp8jF0j82bxVHtxrx87HF8PoG.ykEiyyCKGOB1tWjbdRBXQQN7R2JwAHxl%2FkpAWvaV%2FIs; Path=/; HttpOnly, __cf_bm=xmba.Nkum1545BuZtIF1AkAAJzxI0VLZrdSg2QarH6M-1770549765-1.0.1.1-Twtq9B6vpPFSSJbuRQ9AaEDUB83Sprl4keRU_kvVk7PZqFGUZc1cVqFvyfN14NRX1CG5qT1idcqkSWejx03q6v3KYkPgCga6vJiifoRoVUs; path=/; expires=Sun, 08-Feb-26 11:52:45 GMT; domain=.postman-echo.com; HttpOnly; Secure, _cfuvid=u2FHSl3lIzG1PMEmFIe9J58inYS1BQ8KH5f7Y3RV1Nk-1770549765548-0.0.1.1-604800000; path=/; domain=.postman-echo.com; HttpOnly; Secure; SameSite=None&quot;
#&gt; 
#&gt; $headers$`x-envoy-upstream-service-time`
#&gt; [1] &quot;5&quot;
#&gt; 
#&gt; $headers$`cf-cache-status`
#&gt; [1] &quot;DYNAMIC&quot;
#&gt; 
#&gt; $headers$Server
#&gt; [1] &quot;cloudflare&quot;
#&gt; 
#&gt; 
#&gt; $data
#&gt; [1] &quot;{\&quot;args\&quot;:{},\&quot;headers\&quot;:{\&quot;host\&quot;:\&quot;postman-echo.com\&quot;,\&quot;accept-encoding\&quot;:\&quot;gzip, br\&quot;,\&quot;x-forwarded-proto\&quot;:\&quot;https\&quot;},\&quot;url\&quot;:\&quot;https://postman-echo.com/get\&quot;}&quot;
</code></pre>
<h4 id="sec:ncurl-aio-async-requests">ncurl_aio: Async Requests</h4>
<p><code>ncurl_aio()</code> performs asynchronous requests, returning immediately with an ‘ncurlAio’ object that resolves when the response arrives.</p>
<pre><code class="language-r">res &lt;- ncurl_aio(&quot;https://postman-echo.com/post&quot;,
                 method = &quot;POST&quot;,
                 headers = c(`Content-Type` = &quot;application/json&quot;),
                 data = '{&quot;async&quot;: true}',
                 response = &quot;date&quot;)
res
#&gt; &lt; ncurlAio | $status $headers $data &gt;

call_aio(res)$headers
#&gt; $date
#&gt; [1] &quot;Sun, 08 Feb 2026 11:22:45 GMT&quot;

res$status
#&gt; [1] 200

res$data
#&gt; [1] &quot;{\&quot;args\&quot;:{},\&quot;data\&quot;:{\&quot;async\&quot;:true},\&quot;files\&quot;:{},\&quot;form\&quot;:{},\&quot;headers\&quot;:{\&quot;host\&quot;:\&quot;postman-echo.com\&quot;,\&quot;content-type\&quot;:\&quot;application/json\&quot;,\&quot;accept-encoding\&quot;:\&quot;gzip, br\&quot;,\&quot;x-forwarded-proto\&quot;:\&quot;https\&quot;,\&quot;content-length\&quot;:\&quot;15\&quot;},\&quot;json\&quot;:{\&quot;async\&quot;:true},\&quot;url\&quot;:\&quot;https://postman-echo.com/post\&quot;}&quot;
</code></pre>
<h5 id="sec:promises-integration">Promises Integration</h5>
<p>‘ncurlAio’ objects work anywhere that accepts a ‘promise’ from the promises package, including Shiny ExtendedTask.</p>
<pre><code class="language-r">library(promises)

p &lt;- ncurl_aio(&quot;https://postman-echo.com/get&quot;) |&gt; then(\(x) cat(x$data))
is.promise(p)
#&gt; [1] TRUE
</code></pre>
<h4 id="sec:ncurl-session-persistent-connections">ncurl_session: Persistent Connections</h4>
<p><code>ncurl_session()</code> creates a reusable connection for efficient repeated requests to an API endpoint. Use <code>transact()</code> to send requests over the session.</p>
<pre><code class="language-r">sess &lt;- ncurl_session(&quot;https://postman-echo.com/get&quot;,
                      convert = FALSE,
                      headers = c(`Content-Type` = &quot;application/json&quot;),
                      response = c(&quot;Date&quot;, &quot;Content-Type&quot;))
sess
#&gt; &lt; ncurlSession &gt; - transact() to return data

transact(sess)
#&gt; $status
#&gt; [1] 200
#&gt; 
#&gt; $headers
#&gt; $headers$Date
#&gt; [1] &quot;Sun, 08 Feb 2026 11:22:46 GMT&quot;
#&gt; 
#&gt; $headers$`Content-Type`
#&gt; [1] &quot;application/json; charset=utf-8&quot;
#&gt; 
#&gt; 
#&gt; $data
#&gt;   [1] 7b 22 61 72 67 73 22 3a 7b 7d 2c 22 68 65 61 64 65 72 73 22 3a 7b 22 68 6f 73 74 22 3a
#&gt;  [30] 22 70 6f 73 74 6d 61 6e 2d 65 63 68 6f 2e 63 6f 6d 22 2c 22 61 63 63 65 70 74 2d 65 6e
#&gt;  [59] 63 6f 64 69 6e 67 22 3a 22 67 7a 69 70 2c 20 62 72 22 2c 22 78 2d 66 6f 72 77 61 72 64
#&gt;  [88] 65 64 2d 70 72 6f 74 6f 22 3a 22 68 74 74 70 73 22 2c 22 63 6f 6e 74 65 6e 74 2d 74 79
#&gt; [117] 70 65 22 3a 22 61 70 70 6c 69 63 61 74 69 6f 6e 2f 6a 73 6f 6e 22 7d 2c 22 75 72 6c 22
#&gt; [146] 3a 22 68 74 74 70 73 3a 2f 2f 70 6f 73 74 6d 61 6e 2d 65 63 68 6f 2e 63 6f 6d 2f 67 65
#&gt; [175] 74 22 7d

close(sess)

</code></pre>
<h3 id="sec:2-websocket-client">2. WebSocket Client</h3>
<p><code>stream()</code> provides a low-level byte stream interface for communicating with WebSocket servers and other non-NNG endpoints.</p>
<p>Use <code>textframes = TRUE</code> for servers that expect text frames (most WebSocket servers).</p>
<pre><code class="language-r">s &lt;- stream(dial = &quot;wss://echo.websocket.org/&quot;, textframes = TRUE)
s
#&gt; &lt; nanoStream &gt;
#&gt;  - mode: dialer text frames
#&gt;  - state: opened
#&gt;  - url: wss://echo.websocket.org/
</code></pre>
<p><code>send()</code> and <code>recv()</code>, along with their async counterparts <code>send_aio()</code> and <code>recv_aio()</code>, work on Streams just like Sockets.</p>
<pre><code class="language-r">s |&gt; recv()
#&gt; [1] &quot;Request served by 4d896d95b55478&quot;

s |&gt; send(&quot;hello websocket&quot;)
#&gt; [1] 0

s |&gt; recv()
#&gt; [1] &quot;hello websocket&quot;

s |&gt; recv_aio() -&gt; r

s |&gt; send(&quot;async message&quot;)
#&gt; [1] 0

r[]
#&gt; [1] &quot;async message&quot;

close(s)

</code></pre>
<h3 id="sec:3-unified-http-websocket-server">3. Unified HTTP/WebSocket Server</h3>
<p><code>http_server()</code> creates a single server that can handle HTTP requests, WebSocket connections, and HTTP streaming, all on the same port.</p>
<p>A single call to <code>http_server()</code> sets up one NNG server instance with a list of handlers. HTTP routes, WebSocket endpoints, streaming endpoints, and static file handlers all share the same underlying server – there is no need to run separate processes or bind additional ports. WebSocket clients connect via the standard HTTP upgrade mechanism, so a browser can load a page over HTTP and open a WebSocket connection to the same origin without any cross-origin configuration.</p>
<pre><code class="language-r">server &lt;- http_server(
  url = &quot;http://127.0.0.1:8080&quot;,
  handlers = list(
    handler(&quot;/&quot;, function(req) {
      list(status = 200L, body = &quot;Hello from nanonext!&quot;)
    }),
    handler(&quot;/api/data&quot;, function(req) {
      list(
        status = 200L,
        headers = c(&quot;Content-Type&quot; = &quot;application/json&quot;),
        body = '{&quot;value&quot;: 42}'
      )
    }, method = &quot;GET&quot;)
  )
)
server$start()
# Process requests: repeat later::run_now(Inf)
server$close()

</code></pre>
<p>Specifying port <code>0</code> in the URL lets the OS assign an available port. The actual port is reflected in <code>server$url</code> after <code>$start()</code>, making it easy to set up test servers without port conflicts.</p>
<h4 id="sec:handler-types">Handler Types</h4>
<p>All handler types can be freely mixed in a single server’s handler list:</p>
<table>
<thead>
<tr>
<th align="left">Handler</th>
<th align="left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>handler()</code></td>
<td align="left">HTTP request/response with R callback</td>
</tr>
<tr>
<td align="left"><code>handler_ws()</code></td>
<td align="left">WebSocket with <code>on_message</code>, <code>on_open</code>, <code>on_close</code> callbacks</td>
</tr>
<tr>
<td align="left"><code>handler_stream()</code></td>
<td align="left">Chunked HTTP streaming (SSE, NDJSON, custom)</td>
</tr>
<tr>
<td align="left"><code>handler_file()</code></td>
<td align="left">Serve a single static file</td>
</tr>
<tr>
<td align="left"><code>handler_directory()</code></td>
<td align="left">Serve a directory tree with automatic MIME types</td>
</tr>
<tr>
<td align="left"><code>handler_inline()</code></td>
<td align="left">Serve in-memory content</td>
</tr>
<tr>
<td align="left"><code>handler_redirect()</code></td>
<td align="left">HTTP redirect</td>
</tr>
</tbody>
</table>
<h4 id="sec:http-request-handlers">HTTP Request Handlers</h4>
<p><code>handler()</code> creates HTTP route handlers. The callback receives a request list with <code>method</code>, <code>uri</code>, <code>headers</code>, and <code>body</code>, and returns a response list with <code>status</code>, optional <code>headers</code>, and <code>body</code>.</p>
<pre><code class="language-r"># GET endpoint
h1 &lt;- handler(&quot;/hello&quot;, function(req) {
  list(status = 200L, body = &quot;Hello!&quot;)
})

# POST endpoint echoing the request body
h2 &lt;- handler(&quot;/echo&quot;, function(req) {
  list(status = 200L, body = req$body)
}, method = &quot;POST&quot;)

# Catch-all for any method under a path prefix
h3 &lt;- handler(&quot;/api&quot;, function(req) {
  list(
    status = 200L,
    headers = c(&quot;Content-Type&quot; = &quot;application/json&quot;),
    body = sprintf('{&quot;method&quot;:&quot;%s&quot;,&quot;uri&quot;:&quot;%s&quot;}', req$method, req$uri)
  )
}, method = &quot;*&quot;, prefix = TRUE)

</code></pre>
<h4 id="sec:static-content-handlers">Static Content Handlers</h4>
<pre><code class="language-r"># Serve a single file
h_file &lt;- handler_file(&quot;/favicon.ico&quot;, &quot;path/to/favicon.ico&quot;)

# Serve a directory tree (automatic MIME type detection)
h_dir &lt;- handler_directory(&quot;/static&quot;, &quot;www/assets&quot;)

# Serve inline content
h_inline &lt;- handler_inline(&quot;/robots.txt&quot;, &quot;User-agent: *\nDisallow:&quot;,
                           content_type = &quot;text/plain&quot;)

# Redirect requests
h_redirect &lt;- handler_redirect(&quot;/old-page&quot;, &quot;/new-page&quot;, status = 301L)

</code></pre>
<h4 id="sec:websocket-handlers">WebSocket Handlers</h4>
<p>WebSockets provide full bidirectional communication – the server can push messages to the client, and the client can send messages back.</p>
<p><code>handler_ws()</code> creates WebSocket endpoints. NNG handles the HTTP upgrade handshake and all WebSocket framing (RFC 6455) automatically. Because WebSocket handlers share the same server as HTTP handlers, the browser can load a page and open a WebSocket to the same host and port with no additional setup.</p>
<pre><code class="language-r">clients &lt;- list()

server &lt;- http_server(
  url = &quot;http://127.0.0.1:8080&quot;,
  handlers = list(
    handler_ws(
      &quot;/chat&quot;,
      on_message = function(ws, data) {
        # Broadcast to all connected clients
        for (client in clients) client$send(data)
      },
      on_open = function(ws) {
        clients[[as.character(ws$id)]] &lt;&lt;- ws
      },
      on_close = function(ws) {
        clients[[as.character(ws$id)]] &lt;&lt;- NULL
      },
      textframes = TRUE
    )
  )
)
server$start()

</code></pre>
<p>The <code>ws</code> connection object provides:</p>
<ul>
<li><code>ws$send(data)</code> - Send a message to the client</li>
<li><code>ws$close()</code> - Close the connection</li>
<li><code>ws$id</code> - Unique integer connection identifier</li>
</ul>
<p>Multiple WebSocket endpoints can coexist on the same server, each with independent callbacks and connection tracking. Connection IDs are unique across the entire server, so they are safe to use as keys in a shared data structure spanning multiple handlers.</p>
<h4 id="sec:http-streaming-handlers">HTTP Streaming Handlers</h4>
<p>When you only need to push data in one direction – server to client – streaming is a lighter-weight alternative to WebSockets. It works over plain HTTP, so any client that speaks HTTP can consume the stream without needing a WebSocket library.</p>
<p><code>handler_stream()</code> enables HTTP streaming using chunked transfer encoding, supporting Server-Sent Events (SSE), newline-delimited JSON (NDJSON), and custom streaming formats. Like WebSocket handlers, streaming endpoints share the same server as all other handlers.</p>
<pre><code class="language-r">conns &lt;- list()

server &lt;- http_server(
  url = &quot;http://127.0.0.1:8080&quot;,
  handlers = list(
    # SSE endpoint
    handler_stream(&quot;/events&quot;,
      on_request = function(conn, req) {
        conn$set_header(&quot;Content-Type&quot;, &quot;text/event-stream&quot;)
        conn$set_header(&quot;Cache-Control&quot;, &quot;no-cache&quot;)
        conns[[as.character(conn$id)]] &lt;&lt;- conn
        conn$send(format_sse(data = &quot;connected&quot;, id = &quot;1&quot;))
      },
      on_close = function(conn) {
        conns[[as.character(conn$id)]] &lt;&lt;- NULL
      }
    ),
    # Trigger broadcast via POST
    handler(&quot;/broadcast&quot;, function(req) {
      msg &lt;- format_sse(data = rawToChar(req$body), event = &quot;message&quot;)
      lapply(conns, function(c) c$send(msg))
      list(status = 200L, body = &quot;sent&quot;)
    }, method = &quot;POST&quot;)
  )
)
server$start()

</code></pre>
<h4 id="sec:server-sent-events">Server-Sent Events</h4>
<p><code>format_sse()</code> formats messages according to the SSE specification for browser <code>EventSource</code> clients.</p>
<pre><code class="language-r">format_sse(data = &quot;Hello&quot;)
#&gt; [1] &quot;data: Hello\n\n&quot;

format_sse(data = &quot;Update available&quot;, event = &quot;notification&quot;, id = &quot;42&quot;)
#&gt; [1] &quot;event: notification\nid: 42\ndata: Update available\n\n&quot;

format_sse(data = &quot;Line 1\nLine 2&quot;)
#&gt; [1] &quot;data: Line 1\ndata: Line 2\n\n&quot;
</code></pre>
<p>The streaming connection object provides:</p>
<ul>
<li><code>conn$send(data)</code> - Send a data chunk</li>
<li><code>conn$close()</code> - Close the connection</li>
<li><code>conn$set_status(code)</code> - Set HTTP status (before first send)</li>
<li><code>conn$set_header(name, value)</code> - Set response header (before first send)</li>
<li><code>conn$id</code> - Unique connection identifier</li>
</ul>
<h3 id="sec:4-secure-connections-tls">4. Secure Connections (TLS)</h3>
<p>All web functions support TLS for secure HTTPS/WSS connections via <code>tls_config()</code>.</p>
<h4 id="sec:public-internet-https">Public Internet HTTPS</h4>
<p>When making HTTPS requests over the public internet, you should supply a TLS configuration to validate server certificates.</p>
<p>Root CA certificates in PEM format may be found at:</p>
<ul>
<li>Linux: <code>/etc/ssl/certs/ca-certificates.crt</code> or <code>/etc/pki/tls/certs/ca-bundle.crt</code></li>
<li>macOS: <code>/etc/ssl/cert.pem</code></li>
<li>Windows: download from the <a href="https://www.ccadb.org/resources">Common CA Database</a> site run by Mozilla (select the Server Authentication SSL/TLS certificates text file). <em>This link is not endorsed; use at your own risk.</em></li>
</ul>
<pre><code class="language-r">tls &lt;- tls_config(client = &quot;/etc/ssl/cert.pem&quot;)
ncurl(&quot;https://www.google.com&quot;, tls = tls)

</code></pre>
<h4 id="sec:self-signed-certificates">Self-Signed Certificates</h4>
<p>For internal services or testing, generate self-signed certificates using <code>write_cert()</code>.</p>
<pre><code class="language-r"># Generate self-signed certificate for testing
cert &lt;- write_cert(cn = &quot;127.0.0.1&quot;)

# Server TLS configuration
ser &lt;- tls_config(server = cert$server)

# Client TLS configuration
cli &lt;- tls_config(client = cert$client)

</code></pre>
<p>Use the configurations with servers and clients:</p>
<pre><code class="language-r"># HTTPS server
server &lt;- http_server(
  url = &quot;https://127.0.0.1:0&quot;,
  handlers = list(
    handler(&quot;/&quot;, function(req) list(status = 200L, body = &quot;Secure!&quot;))
  ),
  tls = ser
)
server$start()
server
#&gt; &lt; nanoServer &gt;
#&gt;  - url: https://127.0.0.1:50715 
#&gt;  - state: started

# HTTPS client request
aio &lt;- ncurl_aio(paste0(server$url, &quot;/&quot;), tls = cli)
while (unresolved(aio)) later::run_now(1)
#&gt; {&quot;args&quot;:{},&quot;headers&quot;:{&quot;host&quot;:&quot;postman-echo.com&quot;,&quot;accept-encoding&quot;:&quot;gzip, br&quot;,&quot;x-forwarded-proto&quot;:&quot;https&quot;},&quot;url&quot;:&quot;https://postman-echo.com/get&quot;}
aio$status
#&gt; [1] 200
aio$data
#&gt; [1] &quot;Secure!&quot;

server$close()

</code></pre>
<h3 id="sec:5-client-example-shiny-extendedtask">5. Client Example: Shiny ExtendedTask</h3>
<p>This example demonstrates using <code>ncurl_aio()</code> with Shiny’s ExtendedTask for non-blocking HTTP requests.</p>
<p>If your Shiny app calls an external API, a slow or unresponsive endpoint will block the R process and freeze the app for <em>all</em> users, not just the one who triggered the request.
<code>ncurl_aio()</code> avoids this – it performs the HTTP call on a background thread and returns a promise, so the R process stays free to serve other sessions.
It works anywhere that accepts a promise, including Shiny’s ExtendedTask:</p>
<pre><code class="language-r">library(shiny)
library(bslib)
library(nanonext)

ui &lt;- page_fluid(
  p(&quot;The time is &quot;, textOutput(&quot;current_time&quot;, inline = TRUE)),
  hr(),
  input_task_button(&quot;btn&quot;, &quot;Fetch data&quot;),

  verbatimTextOutput(&quot;result&quot;)
)

server &lt;- function(input, output, session) {
  output$current_time &lt;- renderText({
    invalidateLater(1000)
    format(Sys.time(), &quot;%H:%M:%S %p&quot;)
  })

  task &lt;- ExtendedTask$new(
    function() ncurl_aio(&quot;https://postman-echo.com/get&quot;, response = TRUE)
  ) |&gt; bind_task_button(&quot;btn&quot;)

  observeEvent(input$btn, task$invoke())
  output$result &lt;- renderPrint(task$result()$headers)
}

shinyApp(ui, server)

</code></pre>
<h3 id="sec:6-server-example-quarto-site-with-dynamic-api">6. Server Example: Quarto Site with Dynamic API</h3>
<p>This example shows how the unified server architecture makes it straightforward to combine HTTP or WebSocket handlers to serve different content over the same port.</p>
<p>If you’ve rendered a Quarto website and want to serve it locally – but also expose a dynamic API endpoint alongside it, that’s possible with a single <code>http_server()</code> call:</p>
<pre><code class="language-r">library(nanonext)

server &lt;- http_server(
  url = &quot;http://127.0.0.1:0&quot;,
  handlers = list(
    # Serve your rendered Quarto site
    handler_directory(&quot;/&quot;, &quot;_site&quot;),

    # Add a prediction API endpoint
    handler(&quot;/api/predict&quot;, function(req) {
      input &lt;- secretbase::jsondec(req$body)
      pred &lt;- predict(model, newdata = input)
      list(
        status = 200L,
        headers = c(&quot;Content-Type&quot; = &quot;application/json&quot;),
        body = secretbase::jsonenc(list(prediction = pred))
      )
    }, method = &quot;POST&quot;)
  )
)

server$start()
server$url
# Browse to the URL to see your Quarto site with a live API behind it
</code></pre>
<p>Static pages are served at native speed by NNG while the prediction endpoint is handled by R – no separate processes or ports required. Adding TLS is a single argument.</p>
</div>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</body>
</html>
