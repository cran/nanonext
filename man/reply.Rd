% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/context.R
\name{reply}
\alias{reply}
\title{Reply over Context (RPC Server for Req/Rep Protocol)}
\usage{
reply(
  context,
  execute,
  recv_mode = c("serial", "character", "complex", "double", "integer", "logical",
    "numeric", "raw"),
  send_mode = c("serial", "raw"),
  timeout,
  ...
)
}
\arguments{
\item{context}{a Context.}

\item{execute}{a function which takes the received (converted) data as its
first argument. Can be an anonymous function of the form \code{function(x) do(x)}.
Additional arguments can also be passed in through '...'.}

\item{recv_mode}{[default 'serial'] mode of vector to be received - one of 'serial',
'character', 'complex', 'double', 'integer', 'logical', 'numeric', or 'raw'.
The default 'serial' means a serialised R object, for the other modes,
the raw vector received will be converted into the respective mode.}

\item{send_mode}{[default 'serial'] whether data will be sent serialized or
as a raw vector. Use 'serial' for sending and receiving within R to ensure
perfect reproducibility. Use 'raw' for sending vectors of any type (will be
converted to a raw byte vector for sending) - essential when interfacing
with external applications.}

\item{timeout}{in ms. If unspecified, a socket-specific default timeout will
be used. Note that this applies to receiving the request. The total elapsed
time would also include the time for performing 'execute' on the received
data. The timeout then also applies to sending the result (in the event
that the requestor has become unavailable since sending the request).}

\item{...}{additional arguments passed to the function specified by 'execute'.}
}
\value{
Invisible NULL.
}
\description{
Implements an executor/server for the rep node of the req/rep protocol. Awaits
    data, applies an arbitrary specified function, and returns the result
    to the caller/client.
}
\details{
Receive will block while awaiting a message to arrive and is usually
    the desired behaviour. Set a timeout to allow the function to return
    if no data is forthcoming.

    In the event of an error in either processing the messages or in evaluation
    of the function with respect to the data, a nul byte \code{00} (or serialized
    nul byte) will be sent in reply to the client to signal an error. This makes
    it easy to distigush an error from a NULL return value.
}
\examples{
req <- socket("req", listen = "tcp://127.0.0.1:6546")
rep <- socket("rep", dial = "tcp://127.0.0.1:6546")

ctxq <- context(req)
ctxp <- context(rep)

send_ctx(ctxq, 2022, timeout = 100, echo = FALSE)
reply(ctxp, execute = function(x) x + 1, send_mode = "raw", timeout = 100)
recv_ctx(ctxq, mode = "double", timeout = 100, keep.raw = FALSE)

send_ctx(ctxq, 100, mode = "raw", timeout = 100, echo = FALSE)
reply(ctxp, recv_mode = "double", execute = log, base = 10, timeout = 100)
recv_ctx(ctxq, timeout = 100, keep.raw = FALSE)

close(req)
close(rep)

}
